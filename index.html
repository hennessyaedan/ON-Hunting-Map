<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ontario WMU Map with Harvest Data</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Chroma.js for color interpolation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    #map {
      height: 100vh;
      width: 100%;
    }
    #species-select, #year-select, #per-hunter-container {
      position: absolute;
      right: 10px;
      z-index: 1000;
      padding: 8px;
      font-size: 16px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #species-select {
      top: 10px;
    }
    #year-select {
      top: 50px;
    }
    #per-hunter-container {
      top: 90px;
      display: flex;
      align-items: center;
      padding: 8px;
    }
    #per-hunter-checkbox {
      margin-right: 5px;
    }
    path.leaflet-interactive:focus {
      outline: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <select id="species-select">
    <option value="deer-total">Deer Harvest</option>
    <option value="deer-doe">Doe Harvest</option>
    <option value="deer-buck">Buck Harvest</option>
    <option value="bear">Bear Harvest</option>
    <option value="turkey">Turkey Harvest</option>
    <option value="moose">Moose Harvest</option>
    <option value="wolf">Wolf/Coyote Harvest</option>
  </select>
  <select id="year-select">
    <!-- Populated dynamically -->
  </select>
  <div id="per-hunter-container">
    <input type="checkbox" id="per-hunter-checkbox">
    <label for="per-hunter-checkbox">Harvested per Hunter</label>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize the map and center on Ontario
    const map = L.map('map').setView([50.0, -85.0], 5);

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Function to get parent WMU ID (e.g., "WMU15A" -> "15A", "15A" -> "15")
    function getParentWMU(wmuId) {
      if (!wmuId) return 'Unknown';
      let normalized = wmuId.replace(/^WMU/i, '').replace(/-[A-Z]$/, '').replace(/[A-Z]$/, '');
      return normalized || 'Unknown';
    }

    // Define color scale: red (low) to green (high) with 50 stops
    const colorScale = chroma.scale([
      '#FF0000',    // Red (low)
      '#FF8C00',    // Orange
      '#FFFF00',    // Yellow
      '#008000'     // Green (high)
    ]).mode('lab').colors(50);

    // Log sample color stops for debugging
    console.log('Sample Color Stops:', {
      stop0: colorScale[0],
      stop10: colorScale[10],
      stop20: colorScale[20],
      stop30: colorScale[30],
      stop40: colorScale[40],
      stop49: colorScale[49]
    });

    // Function to get color for harvest or per-hunter value
    function getColor(harvestObj, minVal, maxVal, isPerHunter) {
      if (harvestObj.isNull) return '#808080'; // Gray for no data
      const value = isPerHunter ? harvestObj.perHunterValue : harvestObj.value;
      if (value === 0 || isNaN(value)) return '#FFFFCC'; // Light yellow for zero
      const ratio = (value - minVal) / (maxVal - minVal);
      const colorIndex = Math.min(Math.floor(ratio * 50), 49); // Map to 0–49
      const color = colorScale[colorIndex];
      console.log(`WMU: ${harvestObj.wmuId}, ${isPerHunter ? 'Per Hunter' : 'Harvest'}: ${value.toFixed(2)}, Ratio: ${ratio.toFixed(2)}, Color: ${color}`); // Debug
      return color;
    }

    // Global variables
    let deerHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let doeHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let buckHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let bearHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let turkeyHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let mooseHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let wolfHarvest = { data: {}, min: Infinity, max: -Infinity, minPerHunter: Infinity, maxPerHunter: -Infinity };
    let currentDataset = {
      dataset: deerHarvest,
      species: 'deer',
      column: 'Total Harvest',
      year: '2024',
      isPerHunter: false
    };
    let availableYears = new Set();
    let geojsonLayer = null;

    // Function to process harvest data for a specific year
    function processHarvestData(data, datasetType, selectedYear) {
      const harvestData = {};
      let minHarvest = Infinity, maxHarvest = -Infinity;
      let minPerHunter = Infinity, maxPerHunter = -Infinity;
      const valueBins = { '0-5': 0, '5-10': 0, '10-20': 0, '20-50': 0, '50-100': 0, '100-500': 0, '500+': 0 };
      const perHunterBins = { '0-0.01': 0, '0.01-0.1': 0, '0.1-0.5': 0, '0.5-1': 0, '1-2': 0, '2+': 0 };

      let harvestColumn, activeHuntersColumn = 3, isDeer;
      if (datasetType === 'deer-total') {
        harvestColumn = 6; // Total Harvest
        isDeer = true;
      } else if (datasetType === 'deer-doe') {
        harvestColumn = 4; // Antlerless
        isDeer = true;
      } else if (datasetType === 'deer-buck') {
        harvestColumn = 5; // Antlered
        isDeer = true;
      } else if (datasetType === 'bear') {
        harvestColumn = 4; // Harvest
        isDeer = false;
      } else if (datasetType === 'turkey') {
        harvestColumn = 5; // Total Harvest
        isDeer = false;
      } else if (datasetType === 'moose') {
        harvestColumn = 7; // Total Harvest
        isDeer = false;
      } else if (datasetType === 'wolf') {
        harvestColumn = 4; // Harvest
        isDeer = false;
      }

      console.log(`Processing ${datasetType} data for ${selectedYear}:`, data.records.length, 'records');
      const filteredRecords = data.records
        .filter(record => String(record[2]) === selectedYear && record[1] !== "Total");
      console.log(`Filtered ${datasetType} ${selectedYear} records:`, filteredRecords.length);

      filteredRecords.forEach(record => {
        const wmuId = record[1].trim();
        const isNull = isDeer ? record[harvestColumn] === "NULL" : false;
        const totalHarvest = isNull ? 0 : parseInt(record[harvestColumn], 10);
        const activeHunters = parseInt(record[activeHuntersColumn], 10);
        let perHunterValue = 0;
        let perHunterIsNull = isNull || activeHunters <= 0 || isNaN(activeHunters);

        if (!perHunterIsNull) {
          perHunterValue = totalHarvest / activeHunters;
        }

        harvestData[wmuId] = { wmuId, value: totalHarvest, perHunterValue, isNull, perHunterIsNull };
        if (!isNull && totalHarvest > 0) {
          minHarvest = Math.min(minHarvest, totalHarvest);
          maxHarvest = Math.max(maxHarvest, totalHarvest);
          if (totalHarvest <= 5) valueBins['0-5']++;
          else if (totalHarvest <= 10) valueBins['5-10']++;
          else if (totalHarvest <= 20) valueBins['10-20']++;
          else if (totalHarvest <= 50) valueBins['20-50']++;
          else if (totalHarvest <= 100) valueBins['50-100']++;
          else if (totalHarvest <= 500) valueBins['100-500']++;
          else valueBins['500+']++;
        }
        if (!perHunterIsNull && perHunterValue > 0) {
          minPerHunter = Math.min(minPerHunter, perHunterValue);
          maxPerHunter = Math.max(maxPerHunter, perHunterValue);
          if (perHunterValue <= 0.01) perHunterBins['0-0.01']++;
          else if (perHunterValue <= 0.1) perHunterBins['0.01-0.1']++;
          else if (perHunterValue <= 0.5) perHunterBins['0.1-0.5']++;
          else if (perHunterValue <= 1) perHunterBins['0.5-1']++;
          else if (perHunterValue <= 2) perHunterBins['1-2']++;
          else perHunterBins['2+']++;
        }
      });

      console.log(`${datasetType} ${selectedYear} Min Harvest: ${minHarvest}, Max Harvest: ${maxHarvest}`);
      console.log(`${datasetType} ${selectedYear} Min Per Hunter: ${minPerHunter.toFixed(4)}, Max Per Hunter: ${maxPerHunter.toFixed(4)}`);
      console.log(`${datasetType} ${selectedYear} Harvest Distribution:`, valueBins);
      console.log(`${datasetType} ${selectedYear} Per Hunter Distribution:`, perHunterBins);
      return { data: harvestData, min: minHarvest, max: maxHarvest, minPerHunter, maxPerHunter };
    }

    // Function to populate year dropdown
    function populateYearDropdown() {
      const yearSelect = document.getElementById('year-select');
      const years = Array.from(availableYears).sort((a, b) => b - a);
      years.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (year === '2024') option.selected = true;
        yearSelect.appendChild(option);
      });
      console.log('Available Years:', years);
    }

    // Function to update the map with the selected dataset and year
    function updateMap() {
      const harvestData = currentDataset.dataset.data;
      const minVal = currentDataset.isPerHunter ? currentDataset.dataset.minPerHunter : currentDataset.dataset.min;
      const maxVal = currentDataset.isPerHunter ? currentDataset.dataset.maxPerHunter : currentDataset.dataset.max;
      const speciesName = currentDataset.species;
      const selectedYear = currentDataset.year;
      const isPerHunter = currentDataset.isPerHunter;

      if (geojsonLayer) {
        map.removeLayer(geojsonLayer);
      }

      fetch('./wmu-boundaries.json')
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to load wmu-boundaries.json: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then(geojson => {
          if (geojson.features && geojson.features.length > 0) {
            console.log('GeoJSON First Feature Properties:', geojson.features[0].properties);
          } else {
            console.warn('No features found in GeoJSON');
          }
          geojsonLayer = L.geoJSON(geojson, {
            style: feature => {
              const wmuId = feature.properties.OFFICIAL_NAME || 'Unknown';
              const parentWMU = getParentWMU(wmuId);
              const harvestObj = harvestData[wmuId] || harvestData[parentWMU] || { value: 0, perHunterValue: 0, isNull: true, perHunterIsNull: true };
              console.log(`WMU ${wmuId} (Parent: ${parentWMU}, Dataset: ${currentDataset.column}, Year: ${selectedYear}, PerHunter: ${isPerHunter}): Harvest = ${harvestObj.value}, PerHunter = ${harvestObj.perHunterValue.toFixed(2)}, isNull = ${harvestObj.isNull}, perHunterIsNull = ${harvestObj.perHunterIsNull}`);
              return {
                fillColor: getColor(harvestObj, minVal, maxVal, isPerHunter),
                color: '#666',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.7
              };
            },
            onEachFeature: (feature, layer) => {
              const wmuId = feature.properties.OFFICIAL_NAME || 'Unknown WMU';
              const parentWMU = getParentWMU(wmuId);
              const harvestObj = harvestData[wmuId] || harvestData[parentWMU] || { value: 0, perHunterValue: 0, isNull: true, perHunterIsNull: true };
              const displayWMU = harvestData[wmuId] ? wmuId : parentWMU;
              const tooltipText = isPerHunter
                ? (harvestObj.perHunterIsNull
                    ? `Harvest data not available for ${selectedYear}`
                    : `WMU ${displayWMU}: ${harvestObj.perHunterValue.toFixed(2)} ${speciesName} harvested per hunter`)
                : (harvestObj.isNull
                    ? `Harvest data not available for ${selectedYear}`
                    : `WMU ${displayWMU}: ${harvestObj.value} ${speciesName} harvested`);
              layer.bindTooltip(tooltipText, {
                sticky: true,
                opacity: 0.9
              });
            }
          }).addTo(map);
        })
        .catch(error => {
          console.error('Error loading GeoJSON:', error);
          alert('Failed to load WMU boundaries. Please ensure wmu-boundaries.json is uploaded to Replit.');
        });
    }

    // Load all harvest datasets and extract years
    Promise.all([
      fetch('./deerHarvest2024.json').then(response => {
        if (!response.ok) throw new Error(`Failed to load deerHarvest2024.json: ${response.status}`);
        return response.json().then(data => {
          console.log('Deer raw data:', data);
          data.records.forEach(record => availableYears.add(String(record[2])));
          return data;
        });
      }),
      fetch('./bearHarvest2024.json').then(response => {
        if (!response.ok) throw new Error(`Failed to load bearHarvest2024.json: ${response.status}`);
        return response.json().then(data => {
          console.log('Bear raw data:', data);
          data.records.forEach(record => availableYears.add(String(record[2])));
          return data;
        });
      }),
      fetch('./turkeyHarvest2024.json').then(response => {
        if (!response.ok) throw new Error(`Failed to load turkeyHarvest2024.json: ${response.status}`);
        return response.json().then(data => {
          console.log('Turkey raw data:', data);
          data.records.forEach(record => availableYears.add(String(record[2])));
          return data;
        });
      }),
      fetch('./mooseHarvest2024.json').then(response => {
        if (!response.ok) throw new Error(`Failed to load mooseHarvest2024.json: ${response.status}`);
        return response.json().then(data => {
          console.log('Moose raw data:', data);
          data.records.forEach(record => availableYears.add(String(record[2])));
          return data;
        });
      }),
      fetch('./wolfHarvest2024.json').then(response => {
        if (!response.ok) throw new Error(`Failed to load wolfHarvest2024.json: ${response.status}`);
        return response.json().then(data => {
          console.log('Wolf raw data:', data);
          data.records.forEach(record => availableYears.add(String(record[2])));
          return data;
        });
      })
    ])
      .then(([deerData, bearData, turkeyData, mooseData, wolfData]) => {
        // Populate year dropdown
        populateYearDropdown();

        // Process initial data for 2024
        deerHarvest = processHarvestData(deerData, 'deer-total', '2024');
        doeHarvest = processHarvestData(deerData, 'deer-doe', '2024');
        buckHarvest = processHarvestData(deerData, 'deer-buck', '2024');
        bearHarvest = processHarvestData(bearData, 'bear', '2024');
        turkeyHarvest = processHarvestData(turkeyData, 'turkey', '2024');
        mooseHarvest = processHarvestData(mooseData, 'moose', '2024');
        wolfHarvest = processHarvestData(wolfData, 'wolf', '2024');

        console.log('Deer Harvest 2024 keys:', Object.keys(deerHarvest.data));
        console.log('Doe Harvest 2024 keys:', Object.keys(doeHarvest.data));
        console.log('Buck Harvest 2024 keys:', Object.keys(buckHarvest.data));
        console.log('Bear Harvest 2024 keys:', Object.keys(bearHarvest.data));
        console.log('Turkey Harvest 2024 keys:', Object.keys(turkeyHarvest.data));
        console.log('Moose Harvest 2024 keys:', Object.keys(mooseHarvest.data));
        console.log('Wolf Harvest 2024 keys:', Object.keys(wolfHarvest.data));
        console.log('WMU 15A (Deer):', deerHarvest.data['15A'] || 'Not found');
        console.log('WMU 15A (Wolf):', wolfHarvest.data['15A'] || 'Not found');
        console.log('WMU 15 (Wolf):', wolfHarvest.data['15'] || 'Not found');
        console.log('WMU 82A (Wolf):', wolfHarvest.data['82A'] || 'Not found');
        console.log('WMU 13 (Wolf):', wolfHarvest.data['13'] || 'Not found');
        console.log('WMU 7 (Wolf):', wolfHarvest.data['7'] || 'Not found');
        console.log('WMU 2 (Wolf):', wolfHarvest.data['2'] || 'Not found');
        console.log('WMU 01A (Wolf):', wolfHarvest.data['01A'] || 'Not found');

        // Initial map load
        currentDataset = {
          dataset: deerHarvest,
          species: 'deer',
          column: 'Total Harvest',
          year: '2024',
          isPerHunter: false
        };
        updateMap();

        // Store raw data for reprocessing
        const rawData = {
          deer: deerData,
          bear: bearData,
          turkey: turkeyData,
          moose: mooseData,
          wolf: wolfData
        };

        // Handle species toggle
        document.getElementById('species-select').addEventListener('change', (event) => {
          const value = event.target.value;
          const year = currentDataset.year;
          const isPerHunter = currentDataset.isPerHunter;
          if (value === 'deer-total') {
            currentDataset = { dataset: processHarvestData(rawData.deer, 'deer-total', year), species: 'deer', column: 'Total Harvest', year, isPerHunter };
          } else if (value === 'deer-doe') {
            currentDataset = { dataset: processHarvestData(rawData.deer, 'deer-doe', year), species: 'does', column: 'Antlerless', year, isPerHunter };
          } else if (value === 'deer-buck') {
            currentDataset = { dataset: processHarvestData(rawData.deer, 'deer-buck', year), species: 'bucks', column: 'Antlered', year, isPerHunter };
          } else if (value === 'bear') {
            currentDataset = { dataset: processHarvestData(rawData.bear, 'bear', year), species: 'bears', column: 'Harvest', year, isPerHunter };
          } else if (value === 'turkey') {
            currentDataset = { dataset: processHarvestData(rawData.turkey, 'turkey', year), species: 'turkeys', column: 'Total Harvest', year, isPerHunter };
          } else if (value === 'moose') {
            currentDataset = { dataset: processHarvestData(rawData.moose, 'moose', year), species: 'moose', column: 'Total Harvest', year, isPerHunter };
          } else if (value === 'wolf') {
            currentDataset = { dataset: processHarvestData(rawData.wolf, 'wolf', year), species: 'wolves/coyotes', column: 'Harvest', year, isPerHunter };
          }
          updateMap();
        });

        // Handle year toggle
        document.getElementById('year-select').addEventListener('change', (event) => {
          const year = event.target.value;
          const value = document.getElementById('species-select').value;
          const isPerHunter = currentDataset.isPerHunter;
          if (value === 'deer-total') {
            currentDataset = { dataset: processHarvestData(rawData.deer, 'deer-total', year), species: 'deer', column: 'Total Harvest', year, isPerHunter };
          } else if (value === 'deer-doe') {
            currentDataset = { dataset: processHarvestData(rawData.deer, 'deer-doe', year), species: 'does', column: 'Antlerless', year, isPerHunter };
          } else if (value === 'deer-buck') {
            currentDataset = { dataset: processHarvestData(rawData.deer, 'deer-buck', year), species: 'bucks', column: 'Antlered', year, isPerHunter };
          } else if (value === 'bear') {
            currentDataset = { dataset: processHarvestData(rawData.bear, 'bear', year), species: 'bears', column: 'Harvest', year, isPerHunter };
          } else if (value === 'turkey') {
            currentDataset = { dataset: processHarvestData(rawData.turkey, 'turkey', year), species: 'turkeys', column: 'Total Harvest', year, isPerHunter };
          } else if (value === 'moose') {
            currentDataset = { dataset: processHarvestData(rawData.moose, 'moose', year), species: 'moose', column: 'Total Harvest', year, isPerHunter };
          } else if (value === 'wolf') {
            currentDataset = { dataset: processHarvestData(rawData.wolf, 'wolf', year), species: 'wolves/coyotes', column: 'Harvest', year, isPerHunter };
          }
          updateMap();
        });

        // Handle per-hunter toggle
        document.getElementById('per-hunter-checkbox').addEventListener('change', (event) => {
          currentDataset.isPerHunter = event.target.checked;
          updateMap();
        });
      })
      .catch(error => {
        console.error('Error loading harvest data:', error);
        alert('Failed to load harvest data. Please ensure all JSON files are uploaded to Replit.');
      });
  </script>
</body>
</html>